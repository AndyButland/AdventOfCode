# 2025 Day 3 - Lobby

## User
Create a stub implementation for 2025 Day 3, using the title "Lobby". The method name for part 1 should be GetTotalOutputJoltage and part 2 should be Part2. Input will be an array of strings.

## Assistant
Created stub implementation at `AdventOfCode/2025/Day3.cs`:

```csharp
namespace AdventOfCode.Year2025;

/// <summary>
/// Day 3: Lobby
/// </summary>
public static class Day3
{
    public static int GetTotalOutputJoltage(string[] inputLines)
    {
        throw new NotImplementedException();
    }

    public static int Part2(string[] inputLines)
    {
        throw new NotImplementedException();
    }
}
```

---

## User
Add stub tests for 2025 Day 3 and update AdventOfCode.Runner to allow selection and running of the tasks for this date.

## Assistant
Created test file at `AdventOfCode.Tests/2025/Day3Tests.cs` and updated `AdventOfCode.Runner/Program.cs` with menu entries and switch cases for 25-3a and 25-3b.

---

## User
Add an embedded resource for the input data for 2025 day 3

## Assistant
Created empty input file at `AdventOfCode.Runner/InputData/Year2025/Day3.txt` and updated `AdventOfCode.Runner.csproj` with the `<None Remove>` and `<EmbeddedResource Include>` entries.

---

## User
Implement GetTotalOutputJoltage by defining a total variable initialized to zero. Loop through all input lines which are strings of digits. For each line find the largest 2 digit number that can be made from the digits in the input line. Digits cannot be reordered. For example, if the input line was 12345 the largest 2 digit number is 45. If the input was 492375 the largest 2 digit number is 97. Increment the total variable with the 2 digit number found for each line and return that as the result.

## Assistant
Implemented `GetTotalOutputJoltage` with nested loops to find all valid 2-digit combinations where the tens digit comes before the units digit:

```csharp
public static int GetTotalOutputJoltage(string[] inputLines)
{
    var total = 0;

    foreach (var line in inputLines)
    {
        var largestTwoDigit = 0;

        for (var i = 0; i < line.Length - 1; i++)
        {
            for (var j = i + 1; j < line.Length; j++)
            {
                var twoDigitNumber = (line[i] - '0') * 10 + (line[j] - '0');
                if (twoDigitNumber > largestTwoDigit)
                {
                    largestTwoDigit = twoDigitNumber;
                }
            }
        }

        total += largestTwoDigit;
    }

    return total;
}
```

---

## User
Can you explain line 20 in Day3?

## Assistant
Line 20: `var twoDigitNumber = (line[i] - '0') * 10 + (line[j] - '0');`

This converts two character digits into an integer:

1. **`line[i] - '0'`** - Converts a character digit to its numeric value. Characters have ASCII values, so `'0'` is 48, `'1'` is 49, etc. Subtracting `'0'` gives the actual number (e.g., `'9' - '0'` = 9).

2. **`* 10`** - Makes it the tens place.

3. **`+ (line[j] - '0')`** - Adds the units digit.

**Example:** For `line = "492375"` with `i=1` (digit '9') and `j=4` (digit '7'):
- `('9' - '0') * 10` = `9 * 10` = 90
- `('7' - '0')` = 7
- Result: 97

---

## User
Refactor GetTotalOutputJoltage to extract a private method called GetTotalOutputJoltage and pass an extra parameter called numberOfDigits.

## Assistant
Refactored to extract a private method with `numberOfDigits` parameter and a recursive helper `GetLargestNumber`:

```csharp
public static int GetTotalOutputJoltage(string[] inputLines)
{
    return GetTotalOutputJoltage(inputLines, numberOfDigits: 2);
}

private static int GetTotalOutputJoltage(string[] inputLines, int numberOfDigits)
{
    var total = 0;

    foreach (var line in inputLines)
    {
        var largest = GetLargestNumber(line, numberOfDigits, 0);
        total += largest;
    }

    return total;
}

private static int GetLargestNumber(string line, int digitsRemaining, int startIndex)
{
    // Recursive implementation to find largest N-digit number
    // ...
}
```

---

## User
Although the function for 2 digits still works, when looking for 12 digit results it fails. See the failing test GetTotalOutputJoltageForTwelveDigits_ReturnsExpectedResult.

## Assistant
Fixed integer overflow issue on line 46. The `(int)Math.Pow(10, digitsRemaining - 1)` overflows for 12 digits since `10^11` exceeds `int.MaxValue`. Changed cast to `long`:

```csharp
var number = digit * (long)Math.Pow(10, digitsRemaining - 1) + remaining;
```

---

## User
The implementation works well for small numbers of input lines, but is too slow with inputs of the size defined in Day3.txt. Is there a faster way to find the result?

## Assistant
Analyzed the problem and identified that the recursive approach has O(n^k) time complexity. Proposed a greedy algorithm with O(n·k) complexity.

### Why Greedy Works
- The most significant digit contributes the most to the final number
- Selecting the largest available digit at each step (left to right) is always optimal
- After selecting a digit at position p, we only need to find the largest (k-1)-digit number from positions after p

### Algorithm
```
For each digit position (0 to k-1):
  1. Determine search range: from current position to (n - remaining_digits_needed)
  2. Find the maximum digit in that range
  3. Add digit to result, advance position past the found digit
Convert collected digits to a number
```

### Example
String: "492375", k=2
- First digit: search "49237" (must leave 1 char), max is '9' at index 1
- Second digit: search "375", max is '7' at index 4
- Result: 97

### Implementation

Replaced `GetLargestNumber` with greedy algorithm:

```csharp
private static long GetLargestNumber(string line, int numberOfDigits, int startIndex)
{
    long result = 0;
    var position = startIndex;

    for (var digitIndex = 0; digitIndex < numberOfDigits; digitIndex++)
    {
        var digitsRemaining = numberOfDigits - digitIndex - 1;
        var searchEnd = line.Length - digitsRemaining;

        var maxDigit = 0;
        var maxPosition = position;

        for (var i = position; i < searchEnd; i++)
        {
            var digit = line[i] - '0';
            if (digit > maxDigit)
            {
                maxDigit = digit;
                maxPosition = i;
            }
        }

        result = result * 10 + maxDigit;
        position = maxPosition + 1;
    }

    return result;
}
```

### Complexity Comparison
| Approach | Time | Space |
|----------|------|-------|
| Recursive | O(n^k) | O(k) |
| Greedy | O(n·k) | O(1) |

For n=100, k=12: ~100^12 operations reduced to ~1,200 operations.

All tests pass with the optimized implementation.
