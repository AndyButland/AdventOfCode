# 2025 Day 7 - Laboratories

## Chat Log

### User
Create similar stubs for 2025 Day 7 (runner, implementation, tests, input data as an embedded resource). The name of the task is 'Laboratories'.

### Assistant
Created files:
- `AdventOfCode\2025\Day7.cs` - Stub implementation with `CountNumberOfBeamSplits` and `SolvePart2` methods
- `AdventOfCode.Tests\2025\Day7Tests.cs` - Test class with tests for both parts
- `AdventOfCode.Runner\InputData\Year2025\Day7.txt` - Empty input data file

Updated files:
- `AdventOfCode.Runner\Program.cs` - Added menu options `25-7a` and `25-7b` for Day 7

---

### User
In Day7, CountNumberOfBeamSplits load the input lines into a 2d character array.

### Assistant
Implemented grid loading:

```csharp
int rows = inputLines.Length;
int cols = inputLines[0].Length;
var grid = new char[rows, cols];

for (int row = 0; row < rows; row++)
{
    for (int col = 0; col < cols; col++)
    {
        grid[row, col] = inputLines[row][col];
    }
}
```

---

### User
Consider the 2D array as a set of rows and columns. Iterate each row and within each row iterate each column. If the current cell is a '.' and the cell above is an 'S' or '|' then change the current cell to a '|'. If the current cell is a '^' and the cell above is an 'S' or '|' then change the cells to the left and right of the current cell to '|' (if within bounds).

### Assistant
Implemented the beam propagation logic:

```csharp
for (int row = 0; row < rows; row++)
{
    for (int col = 0; col < cols; col++)
    {
        char current = grid[row, col];
        char above = row > 0 ? grid[row - 1, col] : ' ';

        if (current == '.' && (above == 'S' || above == '|'))
        {
            grid[row, col] = '|';
        }
        else if (current == '^' && (above == 'S' || above == '|'))
        {
            if (col > 0)
                grid[row, col - 1] = '|';
            if (col < cols - 1)
                grid[row, col + 1] = '|';
        }
    }
}
```

Test returned 9 instead of expected 21.

---

### User
The test CountNumberOfBeamSplits_ReturnsExpectedResult is returning 9 not 21 as expected. Can you see what's wrong?

### Assistant
Initially thought the beam should continue through the '^' splitter by setting it to '|'. Added `grid[row, col] = '|'` when '^' triggers. Test then returned 15 instead of 21.

---

### User
Let's print the current state of the grid after each row iteration so I can step through and see where it may be going wrong.

### Assistant
Added `PrintGrid` helper function to output grid state after each row:

```csharp
private static void PrintGrid(char[,] grid, string message)
{
    Console.WriteLine(message);
    int rows = grid.GetLength(0);
    int cols = grid.GetLength(1);
    for (int row = 0; row < rows; row++)
    {
        for (int col = 0; col < cols; col++)
        {
            Console.Write(grid[row, col]);
        }
        Console.WriteLine();
    }
    Console.WriteLine();
}
```

---

### User
The splitting logic is working fine now. The problem is the result we need to return is the number of times we carry out the operation of "Change left and right to '|' if within bounds".

### Assistant
Updated to count splits instead of counting '|' in the last row:

```csharp
int splitCount = 0;

for (int row = 0; row < rows; row++)
{
    for (int col = 0; col < cols; col++)
    {
        char current = grid[row, col];
        char above = row > 0 ? grid[row - 1, col] : ' ';

        if (current == '.' && (above == 'S' || above == '|'))
        {
            grid[row, col] = '|';
        }
        else if (current == '^' && (above == 'S' || above == '|'))
        {
            if (col > 0)
                grid[row, col - 1] = '|';
            if (col < cols - 1)
                grid[row, col + 1] = '|';
            splitCount++;
        }
    }
}

return splitCount;
```

User clarified that the beam does NOT continue through the splitter (no `grid[row, col] = '|'` for '^'). Test passes with result 21.

---

### User
For the GetNumberOfTimelines method consider the "Change left and right to '|' if within bounds" operation as splitting a beam. We need to consider these as quantum events, so the beam can go either left or right. In one timeline, the particle went left, and in the other timeline, the particle went right. We need to count and return the number of unique timelines possible.

### Assistant
Implemented recursive branching approach where each split creates two timelines (left or right):

```csharp
public static long GetNumberOfTimelines(string[] inputLines)
{
    // ... setup grid and find start position ...
    var initialBeams = new HashSet<int> { startCol };
    return CountTimelines(grid, 1, initialBeams);
}

private static long CountTimelines(char[,] grid, int row, HashSet<int> beamColumns)
{
    if (row >= rows || beamColumns.Count == 0)
        return 1; // One complete timeline

    var newBeams = new HashSet<int>();
    var splits = new List<int>();

    foreach (int col in beamColumns)
    {
        char current = grid[row, col];
        if (current == '.')
            newBeams.Add(col);
        else if (current == '^')
            splits.Add(col);
    }

    if (splits.Count == 0)
        return CountTimelines(grid, row + 1, newBeams);

    // Branch for each combination of left/right choices
    long totalTimelines = 0;
    int numCombinations = 1 << splits.Count;

    for (int combo = 0; combo < numCombinations; combo++)
    {
        var branchBeams = new HashSet<int>(newBeams);
        for (int i = 0; i < splits.Count; i++)
        {
            int splitCol = splits[i];
            bool goLeft = (combo & (1 << i)) == 0;
            if (goLeft && splitCol > 0)
                branchBeams.Add(splitCol - 1);
            else if (!goLeft && splitCol < cols - 1)
                branchBeams.Add(splitCol + 1);
        }
        totalTimelines += CountTimelines(grid, row + 1, branchBeams);
    }

    return totalTimelines;
}
```

Test passes with expected result 40.

---

### User
The algorithm for GetNumberOfTimelines is too slow for larger inputs like that found in InputData\Year2025\Day7. Can we do the same thing in a faster way?

### Assistant
Optimized using dynamic programming - track count of timelines per unique beam configuration instead of exploring each timeline:

```csharp
public static long GetNumberOfTimelines(string[] inputLines)
{
    // ... setup grid and find start position ...

    // DP: track count of timelines for each unique beam configuration
    var configurations = new Dictionary<string, long>
    {
        [ConfigKey(new HashSet<int> { startCol })] = 1
    };

    for (int row = 1; row < rows; row++)
    {
        var newConfigurations = new Dictionary<string, long>();

        foreach (var kvp in configurations)
        {
            var beamCols = ParseConfigKey(kvp.Key);
            long timelineCount = kvp.Value;

            var newBeams = new HashSet<int>();
            var splits = new List<int>();

            foreach (int col in beamCols)
            {
                char current = grid[row, col];
                if (current == '.')
                    newBeams.Add(col);
                else if (current == '^')
                    splits.Add(col);
            }

            if (splits.Count == 0)
            {
                AddToConfig(newConfigurations, newBeams, timelineCount);
            }
            else
            {
                int numCombinations = 1 << splits.Count;
                for (int combo = 0; combo < numCombinations; combo++)
                {
                    var branchBeams = new HashSet<int>(newBeams);
                    for (int i = 0; i < splits.Count; i++)
                    {
                        int splitCol = splits[i];
                        bool goLeft = (combo & (1 << i)) == 0;
                        if (goLeft && splitCol > 0)
                            branchBeams.Add(splitCol - 1);
                        else if (!goLeft && splitCol < cols - 1)
                            branchBeams.Add(splitCol + 1);
                    }
                    AddToConfig(newConfigurations, branchBeams, timelineCount);
                }
            }
        }

        configurations = newConfigurations;
    }

    return configurations.Values.Sum();
}
```

Key optimization: when different paths lead to the same beam configuration, their timeline counts are merged rather than explored separately. This is O(rows × configs × 2^splits_per_row) instead of O(2^total_splits).

All tests pass.
